#include "src/compiler/go_generator_extra.h"

#include <cctype>
#include <map>
#include <sstream>

template<class T> grpc::string as_string(T x) {
  std::ostringstream out;
  out << x;
  return out.str();
}

inline bool ClientOnlyStreaming(const grpc_generator::Method *method) {
  return method->ClientStreaming() && !method->ServerStreaming();
}

inline bool ServerOnlyStreaming(const grpc_generator::Method *method) {
  return !method->ClientStreaming() && method->ServerStreaming();
}

namespace grpc_go_generator_extra {
namespace {

// Returns string with first letter to lowerCase
static grpc::string unexportName(grpc::string s) {
  if (s.empty()) return s;
  s[0] = static_cast<char>(std::tolower(s[0]));
  return s;
}

// Returns string with first letter to uppercase
static grpc::string exportName(grpc::string s) {
  if (s.empty()) return s;
  s[0] = static_cast<char>(std::toupper(s[0]));
  return s;
}

static void GenerateError(grpc_generator::Printer *printer,
                   std::map<grpc::string, grpc::string> vars,
                   const bool multiple_return = true) {
  printer->Print(vars, "if $Error_Check$ {\n");
  printer->Indent();
  vars["Return"] = multiple_return ? "nil, err" : "err";
  printer->Print(vars, "return $Return$\n");
  printer->Outdent();
  printer->Print("}\n");
}

// 外部调用库的名字
grpc::string utilsLib = "sc.com/sc/moba/lib/flatc";

// Generates imports for the service
static void GenerateImports(grpc_generator::File *file,
                     grpc_generator::Printer *printer,
                     std::map<grpc::string, grpc::string> vars) {
  vars["filename"] = file->filename();
  vars["utilsLib"] = utilsLib;
  printer->Print("//Generated by gRPC Go moba plugin\n");
  printer->Print("//If you make any local changes, they will be lost\n");
  printer->Print(vars, "//source: $filename$\n\n");
  printer->Print(vars, "package $Package$\n\n");
  printer->Print("import (\n");
  printer->Indent();
  printer->Print(vars, "$context$ \"context\"\n");
  printer->Print("\"os\"\n");
  printer->Print("\"sync\"\n");
  printer->Print("\"time\"\n\n");
  printer->Print(vars, "\"$utilsLib$/codec\"\n");
  printer->Print(vars, "\"$utilsLib$/pools\"\n\n");

  printer->Print("\"github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc\"\n");
  printer->Print("\"github.com/opentracing/opentracing-go\"\n");
  printer->Print("\"github.com/sirupsen/logrus\"\n");
  printer->Print(vars, "$grpc$ \"google.golang.org/grpc\"\n");
  printer->Print("\"google.golang.org/grpc/credentials/insecure\"\n");
  printer->Print("\"google.golang.org/grpc/metadata\"\n");

  printer->Outdent();
  printer->Print(")\n\n");
}

// Generates Server method signature source
static void GenerateServerMethodSignature(const grpc_generator::Method *method,
                                   grpc_generator::Printer *printer,
                                   std::map<grpc::string, grpc::string> vars) {
  vars["Method"] = exportName(method->name());
  vars["Request"] = method->get_input_type_name();
  vars["Response"] = (vars["CustomMethodIO"] == "")
                         ? method->get_output_type_name()
                         : vars["CustomMethodIO"];
  if (method->NoStreaming()) {
    printer->Print(
        vars,
        "$Method$($context$.Context, *$Request$) (*$Response$, error)$Ending$");
  } else if (ServerOnlyStreaming(method)) {
    printer->Print(
        vars, "$Method$(*$Request$, $Service$_$Method$Server) error$Ending$");
  } else {
    printer->Print(vars, "$Method$($Service$_$Method$Server) error$Ending$");
  }
}

static void GenerateServerMethod(const grpc_generator::Method *method,
                          grpc_generator::Printer *printer,
                          std::map<grpc::string, grpc::string> vars) {
  vars["Method"] = exportName(method->name());
  vars["Request"] = method->get_input_type_name();
  vars["Response"] = (vars["CustomMethodIO"] == "")
                         ? method->get_output_type_name()
                         : vars["CustomMethodIO"];
  vars["FullMethodName"] =
      "/" + vars["ServicePrefix"] + vars["Service"] + "/" + vars["Method"];
  vars["Handler"] = "_" + vars["Service"] + "_" + vars["Method"] + "_Handler";
  if (method->NoStreaming()) {
    printer->Print(
        vars,
        "func $Handler$(srv interface{}, ctx $context$.Context,\n\tdec "
        "func(interface{}) error, interceptor $grpc$.UnaryServerInterceptor) "
        "(interface{}, error) {\n");
    printer->Indent();
    printer->Print(vars, "in := new($Request$)\n");
    vars["Error_Check"] = "err := dec(in); err != nil";
    GenerateError(printer, vars);
    printer->Print("if interceptor == nil {\n");
    printer->Indent();
    printer->Print(vars, "return srv.($Service$Server).$Method$(ctx, in)\n");
    printer->Outdent();
    printer->Print("}\n");
    printer->Print(vars, "info := &$grpc$.UnaryServerInfo{\n");
    printer->Indent();
    printer->Print("Server:     srv,\n");
    printer->Print(vars, "FullMethod: \"$FullMethodName$\",\n");
    printer->Outdent();
    printer->Print("}\n");
    printer->Outdent();
    printer->Print("\n");
    printer->Indent();
    printer->Print(vars,
                   "handler := func(ctx $context$.Context, req interface{}) "
                   "(interface{}, error) {\n");
    printer->Indent();
    printer->Print(
        vars, "return srv.($Service$Server).$Method$(ctx, req.(*$Request$))\n");
    printer->Outdent();
    printer->Print("}\n");
    printer->Print("return interceptor(ctx, in, info, handler)\n");
    printer->Outdent();
    printer->Print("}\n");
    return;
  }
  vars["StreamType"] = vars["ServiceUnexported"] + vars["Method"] + "Server";
  printer->Print(
      vars,
      "func $Handler$(srv interface{}, stream $grpc$.ServerStream) error {\n");
  printer->Indent();
  if (ServerOnlyStreaming(method)) {
    printer->Print(vars, "m := new($Request$)\n");
    vars["Error_Check"] = "err := stream.RecvMsg(m); err != nil";
    GenerateError(printer, vars, false);
    printer->Print(
        vars,
        "return srv.($Service$Server).$Method$(m, &$StreamType${stream})\n");
  } else {
    printer->Print(
        vars, "return srv.($Service$Server).$Method$(&$StreamType${stream})\n");
  }
  printer->Outdent();
  printer->Print("}\n\n");

  bool genSend = method->BidiStreaming() || ServerOnlyStreaming(method);
  bool genRecv = method->BidiStreaming() || ClientOnlyStreaming(method);
  bool genSendAndClose = ClientOnlyStreaming(method);

  printer->Print(vars, "type $Service$_$Method$Server interface {\n");
  printer->Indent();
  if (genSend) { printer->Print(vars, "Send(*$Response$) error\n"); }
  if (genRecv) { printer->Print(vars, "Recv() (*$Request$, error)\n"); }
  if (genSendAndClose) {
    printer->Print(vars, "SendAndClose(*$Response$) error\n");
  }
  printer->Print(vars, "$grpc$.ServerStream\n");
  printer->Outdent();
  printer->Print("}\n\n");

  printer->Print(vars, "type $StreamType$ struct {\n");
  printer->Indent();
  printer->Print(vars, "$grpc$.ServerStream\n");
  printer->Outdent();
  printer->Print("}\n\n");

  if (genSend) {
    printer->Print(vars,
                   "func (x *$StreamType$) Send(m *$Response$) error {\n");
    printer->Indent();
    printer->Print("return x.ServerStream.SendMsg(m)\n");
    printer->Outdent();
    printer->Print("}\n\n");
  }
  if (genRecv) {
    printer->Print(vars,
                   "func (x *$StreamType$) Recv() (*$Request$, error) {\n");
    printer->Indent();
    printer->Print(vars, "m := new($Request$)\n");
    vars["Error_Check"] = "err := x.ServerStream.RecvMsg(m); err != nil";
    GenerateError(printer, vars);
    printer->Print("return m, nil\n");
    printer->Outdent();
    printer->Print("}\n\n");
  }
  if (genSendAndClose) {
    printer->Print(
        vars, "func (x *$StreamType$) SendAndClose(m *$Response$) error {\n");
    printer->Indent();
    printer->Print("return x.ServerStream.SendMsg(m)\n");
    printer->Outdent();
    printer->Print("}\n\n");
  }
}

// Generates Client method signature source
static void GenerateClientMethodSignature(const grpc_generator::Method *method,
                                   grpc_generator::Printer *printer,
                                   std::map<grpc::string, grpc::string> vars) {
  vars["Method"] = exportName(method->name());
  vars["Request"] =
      ", in *" + ((vars["CustomMethodIO"] == "") ? method->get_input_type_name()
                                                 : vars["CustomMethodIO"]);
  if (ClientOnlyStreaming(method) || method->BidiStreaming()) {
    vars["Request"] = "";
  }
  vars["Response"] = "*" + method->get_output_type_name();
  if (ClientOnlyStreaming(method) || method->BidiStreaming() ||
      ServerOnlyStreaming(method)) {
    vars["Response"] = vars["Service"] + "_" + vars["Method"] + "Client";
  }
  printer->Print(vars,
                 "$Method$(ctx $context$.Context$Request$,\n\topts "
                 "...$grpc$.CallOption) ($Response$, error)$Ending$");
}

static void GenerateClientMethodSignatureExtra(const grpc_generator::Method *method,
                                   grpc_generator::Printer *printer,
                                   std::map<grpc::string, grpc::string> vars) {
  vars["Method"] = exportName(method->name());
  vars["Request"] = ", req *" + method->get_input_type_name() + "T";

  if (ClientOnlyStreaming(method) || method->BidiStreaming()) {
    vars["Request"] = "";
  }
  vars["Response"] = "*" + method->get_output_type_name() + "T";
  if (ClientOnlyStreaming(method) || method->BidiStreaming() ||
      ServerOnlyStreaming(method)) {
    vars["Response"] = vars["Service"] + "_" + vars["Method"] + "Client";
  }
  printer->Print(vars,"func $Method$(ctx $context$.Context$Request$, opts ...$grpc$.CallOption) ($Response$, error){\n");
}

// Generates Client method source
static void GenerateClientMethod(const grpc_generator::Method *method,
                          grpc_generator::Printer *printer,
                          std::map<grpc::string, grpc::string> vars) {
  printer->Print(vars, "func (c *$ServiceUnexported$Client) ");
  vars["Ending"] = " {\n";
  GenerateClientMethodSignature(method, printer, vars);
  printer->Indent();
  vars["Method"] = exportName(method->name());
  vars["Request"] = (vars["CustomMethodIO"] == "")
                        ? method->get_input_type_name()
                        : vars["CustomMethodIO"];
  vars["Response"] = method->get_output_type_name();
  vars["FullMethodName"] =
      "/" + vars["ServicePrefix"] + vars["Service"] + "/" + vars["Method"];
  if (method->NoStreaming()) {
    printer->Print(vars, "out := new($Response$)\n");
    printer->Print(
        vars,
        "err := c.cc.Invoke(ctx, \"$FullMethodName$\", in, out, opts...)\n");
    vars["Error_Check"] = "err != nil";
    GenerateError(printer, vars);
    printer->Print("return out, nil\n");
    printer->Outdent();
    printer->Print("}\n\n");
    return;
  }
  vars["StreamType"] = vars["ServiceUnexported"] + vars["Method"] + "Client";
  printer->Print(vars,
                 "stream, err := c.cc.NewStream(ctx, &$MethodDesc$, "
                 "\"$FullMethodName$\", opts...)\n");
  vars["Error_Check"] = "err != nil";
  GenerateError(printer, vars);

  printer->Print(vars, "x := &$StreamType${stream}\n");
  if (ServerOnlyStreaming(method)) {
    vars["Error_Check"] = "err := x.ClientStream.SendMsg(in); err != nil";
    GenerateError(printer, vars);
    vars["Error_Check"] = "err := x.ClientStream.CloseSend(); err != nil";
    GenerateError(printer, vars);
  }
  printer->Print("return x, nil\n");
  printer->Outdent();
  printer->Print("}\n\n");

  bool genSend = method->BidiStreaming() || ClientOnlyStreaming(method);
  bool genRecv = method->BidiStreaming() || ServerOnlyStreaming(method);
  bool genCloseAndRecv = ClientOnlyStreaming(method);

  // Stream interface
  printer->Print(vars, "type $Service$_$Method$Client interface {\n");
  printer->Indent();
  if (genSend) { printer->Print(vars, "Send(*$Request$) error\n"); }
  if (genRecv) { printer->Print(vars, "Recv() (*$Response$, error)\n"); }
  if (genCloseAndRecv) {
    printer->Print(vars, "CloseAndRecv() (*$Response$, error)\n");
  }
  printer->Print(vars, "$grpc$.ClientStream\n");
  printer->Outdent();
  printer->Print("}\n\n");

  // Stream Client
  printer->Print(vars, "type $StreamType$ struct {\n");
  printer->Indent();
  printer->Print(vars, "$grpc$.ClientStream\n");
  printer->Outdent();
  printer->Print("}\n\n");

  if (genSend) {
    printer->Print(vars, "func (x *$StreamType$) Send(m *$Request$) error {\n");
    printer->Indent();
    printer->Print("return x.ClientStream.SendMsg(m)\n");
    printer->Outdent();
    printer->Print("}\n\n");
  }

  if (genRecv) {
    printer->Print(vars,
                   "func (x *$StreamType$) Recv() (*$Response$, error) {\n");
    printer->Indent();
    printer->Print(vars, "m := new($Response$)\n");
    vars["Error_Check"] = "err := x.ClientStream.RecvMsg(m); err != nil";
    GenerateError(printer, vars);
    printer->Print("return m, nil\n");
    printer->Outdent();
    printer->Print("}\n\n");
  }

  if (genCloseAndRecv) {
    printer->Print(
        vars, "func (x *$StreamType$) CloseAndRecv() (*$Response$, error) {\n");
    printer->Indent();
    vars["Error_Check"] = "err := x.ClientStream.CloseSend(); err != nil";
    GenerateError(printer, vars);
    printer->Print(vars, "m := new($Response$)\n");
    vars["Error_Check"] = "err := x.ClientStream.RecvMsg(m); err != nil";
    GenerateError(printer, vars);
    printer->Print("return m, nil\n");
    printer->Outdent();
    printer->Print("}\n\n");
  }
}

// 本地调用函数
static void GenerateClientLocalMethod(const grpc_generator::Method *method,
                          grpc_generator::Printer *printer,
                          std::map<grpc::string, grpc::string> vars){
  vars["OutPut"] = method->get_output_type_name();
  printer->Print(vars, "if os.Getenv(\"ALL_IN_ONE\") == \"true\" {\n");
  printer->Indent();

  // 本地调用
  printer->Print(vars, "if local$Service$Srv == nil {\n");
  printer->Print(vars, "\ttime.Sleep(time.Second)\n}\n\n");
  printer->Print(vars, "rp, err := local$Service$Srv.$Method$(ctx, req)\n");
  printer->Print(vars, "if err != nil {\n\treturn nil, err\n}\n");
  printer->Print(vars, "return rp, nil\n");
  printer->Outdent();
  printer->Print(vars, "}\n\n");
}

// Generates Client outside method source
static void GenerateClientOutsideMethod(const grpc_generator::Method *method,
                          grpc_generator::Printer *printer,
                          std::map<grpc::string, grpc::string> vars) {
  GenerateClientMethodSignatureExtra(method, printer, vars);
  printer->Indent();
  vars["Method"] = exportName(method->name());

  vars["Request"] = method->get_input_type_name() + "T";
  vars["Response"] = method->get_output_type_name() + "T";

  vars["FullMethodName"] =
      "/" + vars["ServicePrefix"] + vars["Service"] + "/" + vars["Method"];

  printer->Print(vars, "isWs := false\n");
  printer->Print(vars, "for _, opt := range opts {\n");
  printer->Indent();
  printer->Print(vars, "metaData, _ := opt.(grpc.PerRPCCredsCallOption).Creds.GetRequestMetadata(ctx)\n");
  printer->Print(vars, "metaData1 := make(map[string][]string)\n");
  printer->Print(vars, "for k, v := range metaData {\n");

  printer->Indent();
  printer->Print(vars, "metaData1[k] = []string{v}\n");
  printer->Print(vars, "if k == \"IsWsClient\" && v == \"true\" {\n");
  printer->Print(vars, "\tisWs = true\n");
  printer->Print(vars, "}\n");
  printer->Outdent();
  printer->Print(vars, "}\n");
  printer->Print(vars, "ctx = metadata.NewIncomingContext(ctx, metaData1)\n");
  printer->Outdent();
  printer->Print(vars, "}\n");

  // 本地调用
  GenerateClientLocalMethod(method, printer, vars);

  // 初始化单例客户端
  printer->Print(vars, "if callSingleMethodFunc != nil {\n");
  printer->Indent();
  printer->Print(vars, "$LowerService$ClientOnce.Do(callSingleMethodFunc)\n");
  printer->Outdent();
  printer->Print(vars, "}\n\n");

  // 远程调用
  printer->Print(vars, "dialOpts := []grpc.DialOption{\n");
  printer->Indent();
  printer->Print(vars, "grpc.WithTransportCredentials(insecure.NewCredentials()),\n");
  printer->Print(vars, "grpc.WithDefaultCallOptions(grpc.ForceCodec(codec.FlatbuffersCodec{})),\n");
  printer->Print(vars, "grpc.WithUnaryInterceptor(otgrpc.OpenTracingClientInterceptor(opentracing.GlobalTracer(), otgrpc.LogPayloads())),\n");
  printer->Outdent();
  printer->Print(vars, "}\n\n");

  printer->Print(vars, "nowt := time.Now()\n");
  printer->Print(vars, "$LowerService$ClientData.Logger.Debugln(\"send rpc $Method$, time: \", nowt.Unix())\n\n");
  printer->Print(vars, "opts = append(opts, grpc.CallContentSubtype(\"flatbuffers\"))\n\n");
  printer->Print(vars, "cc, err := $LowerService$ClientData.Pool.GetConn(ctx, $LowerService$ClientData.Addr, dialOpts...)\n");
  printer->Print(vars, "if err != nil {\n\treturn nil, err\n}\ndefer cc.Close()\n");
  printer->Print(vars, "rp, err := New$Service$Client(cc).$Method$(ctx, req, opts...)\n");
  printer->Print(vars, "if err != nil {\n\treturn nil, err\n}\n\n");
  printer->Print(vars, "$LowerService$ClientData.Logger.Debugf(\"$Method$ recv rpc, time:%v, is ws:%v\", time.Now().Sub(nowt), isWs)\n");
  printer->Print(vars, "return rp, nil\n");
  printer->Outdent();
  printer->Print(vars, "}\n\n");

//   if (method->NoStreaming()) {
//     printer->Print(vars, "out := new($Response$)\n");
//     printer->Print(
//         vars,
//         "err := c.cc.Invoke(ctx, \"$FullMethodName$\", in, out, opts...)\n");
//     vars["Error_Check"] = "err != nil";
//     GenerateError(printer, vars);
//     printer->Print("return out, nil\n");
//     printer->Outdent();
//     printer->Print("}\n\n");
//     return;
//   }
//   vars["StreamType"] = vars["ServiceUnexported"] + vars["Method"] + "Client";
//   printer->Print(vars,
//                  "stream, err := c.cc.NewStream(ctx, &$MethodDesc$, "
//                  "\"$FullMethodName$\", opts...)\n");
//   vars["Error_Check"] = "err != nil";
//   GenerateError(printer, vars);

//   printer->Print(vars, "x := &$StreamType${stream}\n");
//   if (ServerOnlyStreaming(method)) {
//     vars["Error_Check"] = "err := x.ClientStream.SendMsg(in); err != nil";
//     GenerateError(printer, vars);
//     vars["Error_Check"] = "err := x.ClientStream.CloseSend(); err != nil";
//     GenerateError(printer, vars);
//   }
//   printer->Print("return x, nil\n");
//   printer->Outdent();
//   printer->Print("}\n\n");

//   bool genSend = method->BidiStreaming() || ClientOnlyStreaming(method);
//   bool genRecv = method->BidiStreaming() || ServerOnlyStreaming(method);
//   bool genCloseAndRecv = ClientOnlyStreaming(method);

//   // Stream interface
//   printer->Print(vars, "type $Service$_$Method$Client interface {\n");
//   printer->Indent();
//   if (genSend) { printer->Print(vars, "Send(*$Request$) error\n"); }
//   if (genRecv) { printer->Print(vars, "Recv() (*$Response$, error)\n"); }
//   if (genCloseAndRecv) {
//     printer->Print(vars, "CloseAndRecv() (*$Response$, error)\n");
//   }
//   printer->Print(vars, "$grpc$.ClientStream\n");
//   printer->Outdent();
//   printer->Print("}\n\n");

//   // Stream Client
//   printer->Print(vars, "type $StreamType$ struct {\n");
//   printer->Indent();
//   printer->Print(vars, "$grpc$.ClientStream\n");
//   printer->Outdent();
//   printer->Print("}\n\n");

//   if (genSend) {
//     printer->Print(vars, "func (x *$StreamType$) Send(m *$Request$) error {\n");
//     printer->Indent();
//     printer->Print("return x.ClientStream.SendMsg(m)\n");
//     printer->Outdent();
//     printer->Print("}\n\n");
//   }

//   if (genRecv) {
//     printer->Print(vars,
//                    "func (x *$StreamType$) Recv() (*$Response$, error) {\n");
//     printer->Indent();
//     printer->Print(vars, "m := new($Response$)\n");
//     vars["Error_Check"] = "err := x.ClientStream.RecvMsg(m); err != nil";
//     GenerateError(printer, vars);
//     printer->Print("return m, nil\n");
//     printer->Outdent();
//     printer->Print("}\n\n");
//   }

//   if (genCloseAndRecv) {
//     printer->Print(
//         vars, "func (x *$StreamType$) CloseAndRecv() (*$Response$, error) {\n");
//     printer->Indent();
//     vars["Error_Check"] = "err := x.ClientStream.CloseSend(); err != nil";
//     GenerateError(printer, vars);
//     printer->Print(vars, "m := new($Response$)\n");
//     vars["Error_Check"] = "err := x.ClientStream.RecvMsg(m); err != nil";
//     GenerateError(printer, vars);
//     printer->Print("return m, nil\n");
//     printer->Outdent();
//     printer->Print("}\n\n");
//   }
}

// Generates client API for the service
void GenerateService(const grpc_generator::Service *service,
                     grpc_generator::Printer *printer,
                     std::map<grpc::string, grpc::string> vars) {
  vars["Service"] = exportName(service->name());
  vars["LowerService"] = unexportName(service->name());

  // Client struct
  printer->Print(vars, "// grpc Client API for $Service$ service\n");
  printer->Print(vars, "type $LowerService$ClientInfo struct {\n");
  printer->Indent();
  printer->Print(vars, "Addr   string\n");
  printer->Print(vars, "Logger *logrus.Logger\n");
  printer->Print(vars, "Pool   *pools.GRPCPool\n");
  printer->Outdent();
  printer->Print("}\n\n");

  printer->Print(vars, "var $LowerService$ClientData *$LowerService$ClientInfo\n");
  printer->Print(vars, "var $LowerService$ClientOnce = new(sync.Once)\n");
  printer->Print(vars, "var callSingleMethodFunc func()\n\n");


  printer->Print(vars, "// 初始化客户端结构\n");
  printer->Print(vars, "func NewClient(addr string, logger *logrus.Logger) {\n");
  printer->Indent();
  printer->Print(vars, "callSingleMethodFunc = func() {\n");
  printer->Indent();
  printer->Print(vars, "c := newSigngleClient(addr, logger)\n");
  printer->Print(vars, "$LowerService$ClientData = c\n");
  printer->Outdent();
  printer->Print(vars, "}\n");
  printer->Outdent();
  printer->Print(vars, "}\n\n");

  for (int i = 0; i < service->method_count(); i++) {
    auto method = service->method(i);

    // 流的生成不做处理
    if (method->NoStreaming()) {
        GenerateClientOutsideMethod(method.get(), printer, vars);
    }
  }

  // 单例客户端
  printer->Print(vars, "func newSigngleClient(addr string, log *logrus.Logger) *$LowerService$ClientInfo {\n");
  printer->Indent();
  printer->Print(vars, "c := &$LowerService$ClientInfo{\n");
  printer->Print(vars, "\tAddr:   addr,\n");
  printer->Print(vars, "\tLogger: log,\n");
  printer->Print(vars, "\tPool:   pools.NewGRPCPool(pools.DefaultGRPCPoolOption),\n");
  printer->Print(vars, "}\n");
  printer->Print(vars, "return c\n");
  printer->Outdent();
  printer->Print(vars, "}\n");



//   // Server Interface
//   printer->Print(vars, "// Server API for $Service$ service\n");
//   printer->Print(vars, "type $Service$Server interface {\n");
//   printer->Indent();
//   vars["Ending"] = "\n";
//   for (int i = 0; i < service->method_count(); i++) {
//     GenerateServerMethodSignature(service->method(i).get(), printer, vars);
//   }
//   printer->Print(vars, "mustEmbedUnimplemented$Service$Server()\n");
//   printer->Outdent();
//   printer->Print("}\n\n");

//   printer->Print(vars, "type Unimplemented$Service$Server struct {\n");
//   printer->Print("}\n\n");

//   vars["Ending"] = " {\n";
//   for (int i = 0; i < service->method_count(); i++) {
//     auto method = service->method(i);
//     vars["Method"] = exportName(method->name());
//     vars["Nil"] = method->NoStreaming() ? "nil, " : "";
//     printer->Print(vars, "func (Unimplemented$Service$Server) ");
//     GenerateServerMethodSignature(method.get(), printer, vars);
//     printer->Indent();
//     printer->Print(vars,
//                    "return $Nil$status.Errorf(codes.Unimplemented, \"method "
//                    "$Method$ not implemented\")\n");
//     printer->Outdent();
//     printer->Print("}\n");
//     printer->Print("\n");
//   }

//   printer->Print(vars,
//                  "func (Unimplemented$Service$Server) "
//                  "mustEmbedUnimplemented$Service$Server() {}");
//   printer->Print("\n\n");

//   printer->Print(vars, "type Unsafe$Service$Server interface {\n");
//   printer->Indent();
//   printer->Print(vars, "mustEmbedUnimplemented$Service$Server()\n");
//   printer->Outdent();
//   printer->Print("}\n\n");
//   // Server registration.
//   printer->Print(vars,
//                  "func Register$Service$Server(s $grpc$.ServiceRegistrar, srv "
//                  "$Service$Server) {\n");
//   printer->Indent();
//   printer->Print(vars, "s.RegisterService(&$ServiceDesc$, srv)\n");
//   printer->Outdent();
//   printer->Print("}\n\n");

//   for (int i = 0; i < service->method_count(); i++) {
//     GenerateServerMethod(service->method(i).get(), printer, vars);
//   }

//   // Service Descriptor
//   printer->Print(vars, "var $ServiceDesc$ = $grpc$.ServiceDesc{\n");
//   printer->Indent();
//   printer->Print(vars, "ServiceName: \"$ServicePrefix$$Service$\",\n");
//   printer->Print(vars, "HandlerType: (*$Service$Server)(nil),\n");
//   printer->Print(vars, "Methods: []$grpc$.MethodDesc{\n");
//   printer->Indent();
//   for (int i = 0; i < service->method_count(); i++) {
//     auto method = service->method(i);
//     vars["Method"] = exportName(method->name());
//     vars["Handler"] = "_" + vars["Service"] + "_" + vars["Method"] + "_Handler";
//     if (method->NoStreaming()) {
//       printer->Print("{\n");
//       printer->Indent();
//       printer->Print(vars, "MethodName: \"$Method$\",\n");
//       printer->Print(vars, "Handler:    $Handler$,\n");
//       printer->Outdent();
//       printer->Print("},\n");
//     }
//   }
//   printer->Outdent();
//   printer->Print("},\n");
//   printer->Print(vars, "Streams: []$grpc$.StreamDesc{\n");
//   printer->Indent();
//   for (int i = 0; i < service->method_count(); i++) {
//     auto method = service->method(i);
//     vars["Method"] = exportName(method->name());
//     vars["Handler"] = "_" + vars["Service"] + "_" + vars["Method"] + "_Handler";
//     if (!method->NoStreaming()) {
//       printer->Print("{\n");
//       printer->Indent();
//       printer->Print(vars, "StreamName:    \"$Method$\",\n");
//       printer->Print(vars, "Handler:       $Handler$,\n");
//       if (ClientOnlyStreaming(method.get())) {
//         printer->Print("ClientStreams: true,\n");
//       } else if (ServerOnlyStreaming(method.get())) {
//         printer->Print("ServerStreams: true,\n");
//       } else {
//         printer->Print("ServerStreams: true,\n");
//         printer->Print("ClientStreams: true,\n");
//       }
//       printer->Outdent();
//       printer->Print("},\n");
//     }
//   }
//   printer->Outdent();
//   printer->Print("},\n");
//   printer->Outdent();
//   printer->Print("}\n");
}
}  // namespace

// Returns source for the service
grpc::string GenerateServiceSource(grpc_generator::File *file,
                                   const grpc_generator::Service *service,
                                   grpc_go_generator_extra::Parameters *parameters) {
  grpc::string out;
  auto p = file->CreatePrinter(&out, '\t');
  p->SetIndentationSize(1);
  auto printer = p.get();
  std::map<grpc::string, grpc::string> vars;
  vars["Package"] = parameters->package_name;
  vars["ServicePrefix"] = parameters->service_prefix;
  if (!parameters->service_prefix.empty()) vars["ServicePrefix"].append(".");
  vars["grpc"] = "grpc";
  vars["context"] = "context";
  GenerateImports(file, printer, vars);
  if (parameters->custom_method_io_type != "") {
    vars["CustomMethodIO"] = parameters->custom_method_io_type;
  }
  GenerateService(service, printer, vars);
  return out;

}
}  // Namespace grpc_go_generator_extra
